<html>
	<head>
		<script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v5.0.1.min.js"></script>
    <script defer="defer">
		load = function () {
			var stage = new Kinetic.Stage({
				container: 'container',
				width: 1920,
				height: 1080
			});
			
			var layer = new Kinetic.Layer();
			var secondLayer = new Kinetic.Layer();
			var mainLayer = new Kinetic.Layer();
			
			var xc = stage.width()/2;
			
			var yc = stage.height()/2;
			
			var xt = stage.width()/2;
			
			var yt = stage.height()/2;
			
			var radius = 300;
			
			var radiusTwo = 150;
			
			var pax = [];
			
			//Pushes the coordinates to the 3D Array (This works correctly)
			for (var i = 0; i < stage.height()/12; i++){
				pax[i] = [];
				for (var j = 0; j < stage.width()/12; j++){
					pax[i][j] = [];
					pax[i][j].push(j*12-(stage.width()/2)+xt,i*-12+(stage.height()/2)+yt);
				};
			}
			
			var foo = [];
			
			for (var i = 0; i < stage.height()/24; i++){
				foo[i] = [];
			}
			
			console.log(xt-(13*(Math.ceil(xt/13)))+(i*13)); //left most possible triangle (without orientation) and loop iteration
			
			if (((Math.ceil((stage.width()-xt)/13))%2=0)&&((Math.ceil((stage.height()-yt)/24))%2=0)) { return  //finding triangle orientation
			
			function createBox(x, y) { //box creation
			
				var box = new Kinetic.Rect({
					x: x,
					y: y,
					width: 11,
					height: 11,
					fillRed: 17,
					fillGreen: 17,
					fillBlue: 17,
					closed: true,
					shadowColor: '#5febff',
					shadowBlur: 3,
					shadowOpacity: 0.18
				});
				
				if (((Math.abs(Math.pow((xt-x),2)) + Math.abs(Math.pow((yt-y),2))) < Math.pow(radius,2))&&((Math.abs(Math.pow((xt-x),2)) + Math.abs(Math.pow((yt-y),2))) > Math.pow(radiusTwo,2))){
					layer.add(box); 
				};
			}
			
			function createTri(x, y, z) {
				var tri = new Kinetic.RegularPolygon({
					x: x,
					y: y,
					sides: 3,
					radius: 15,
					rotation: z,
					fillRed: 17,
					fillGreen: 17,
					fillBlue: 17,
					closed: true,
					shadowColor: '#5febff',
					shadowBlur: 5,
					shadowOpacity: 0.18
				});
				
				if (((Math.abs(Math.pow((xt-x),2)) + Math.abs(Math.pow((yt-y),2))) < Math.pow(radius,2))&&((Math.abs(Math.pow((xt-x),2)) + Math.abs(Math.pow((yt-y),2))) > Math.pow(radiusTwo,2))){ //Need a buffer for ring
					layer.add(tri);
				};
			}


			//drawing triangles to correct grid coordinates (This works properly)
			for (var i = 0; i < pax.length; i++){
				for (var j = 0; j < pax[i].length; j++){
					createBox(pax[i][j][0],pax[i][j][1]);
				};
			}
			
			var top = new Kinetic.Line({
				points: [xc-57, yc-64, xc+55, yc-64, xc+64, yc-47, xc+54, yc-41, xc-56, yc-41, xc-66, yc-47],
				fill: '#111111',
				closed: true,
				shadowColor: '#5febff',
				shadowBlur: 5,
				shadowOpacity: 0.18,
			});
			
			var right = new Kinetic.Line({
				points: [xc+66, yc-43, xc+76, yc-25, xc+22, yc+70, xc+2, yc+70, xc+2, yc+58, xc+54, yc-36],
				fill: '#111111',
				closed: true,
				shadowColor: '#5febff',
				shadowBlur: 5,
				shadowOpacity: 0.18,
			});
			
			var left = new Kinetic.Line({
				points: [xc-68, yc-43, xc-56, yc-36, xc-3, yc+58, xc-3, yc+70, xc-23, yc+70, xc-78, yc-25],
				fill: '#111111',
				closed: true,
				shadowColor: '#5febff',
				shadowBlur: 5,
				shadowOpacity: 0.18,
			});
			
			var cent = new Kinetic.RegularPolygon({
				x: xc-1,
				y: yc-7,
				sides: 6,
				radius: 12,
				rotation: 90,
				fillRed: 51,
				fillGreen: 26,
				fillBlue: 6,
				strokeRed: 255,
				strokeGreen: 138,
				strokeBlue: 0,
				strokeAlpha: 0.6,
				strokeWidth: 1,
				closed: true,
				shadowColor: '#ff5200',
				shadowBlur: 10,
			});
		
			mainLayer.add(top);
			mainLayer.add(right);
			mainLayer.add(left);
			mainLayer.add(cent);


			stage.add(mainLayer);
			stage.add(layer);
			stage.add(secondLayer);
			
			layer.on('mouseenter', function(evt) {
				var shape = evt.targetNode;
				shape.moveTo(secondLayer);
				shape.setAttrs({
					shadowColor: '#ff5200',
					shadowBlur: 7,
					shadowOpacity: 1,
					
				});
				stage.draw()
				var tween = new Kinetic.Tween({
					node: shape,
					duration: 0.00001,
					fillRed: 51,
					fillGreen: 26,
					fillBlue: 6,
					strokeRed: 255,
					strokeGreen: 138,
					strokeBlue: 0,
					strokeAlpha: 0.4,
					strokeWidth: 1,
				});
				tween.play()
			});
		  
			secondLayer.on('mouseout', function(evt) {
				var shape = evt.targetNode;
				shape.setAttrs({
					shadowColor: '#5febff',
					shadowBlur: 3,
					shadowOpacity: 0.18,
				});
				var tween = new Kinetic.Tween({
					node: shape,
					duration: 0.5,
					fillRed: 17,
					fillGreen: 17,
					fillBlue: 17,
					strokeAlpha: 0,
					onFinish: function() {
						shape.moveTo(layer);
						layer.draw();
					}
				});
				tween.play();		
			});
			
		}
		document.addEventListener('DOMContentLoaded', load, false);    
    </script>
		<style>
			*{
				margin:0; 
				padding:0; 
				border: 0; 
				line-height: 100%; 
				font-size: 100%;
			}
			#paradigm{
				background-color: #181818;
				height: 100%;
				width: 100%;
				overflow: hidden
			}
			#container {
				position:relative;
				top:50%;
				left:50%;
				margin-left: -960px;
				margin-top: -540px;
			}
		</style>
	</head>
	<body>
		<div id="paradigm">
    <div id="container"></div>
</div>
	</body>
</html>